<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Astynax&#x27;s ClojureScript Book</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="what_is_clojure.html"><strong aria-hidden="true">1.</strong> Clojure, что это</a></li><li class="chapter-item expanded "><a href="edn.html"><strong aria-hidden="true">2.</strong> Данные == код</a></li><li class="chapter-item expanded "><a href="syntax.html"><strong aria-hidden="true">3.</strong> Синтаксис Clojure</a></li><li class="chapter-item expanded "><a href="data_manipulation.html"><strong aria-hidden="true">4.</strong> Работа с данными</a></li><li class="chapter-item expanded "><a href="toolchain.html"><strong aria-hidden="true">5.</strong> Инструментарий разработчика</a></li><li class="chapter-item expanded "><a href="js_interop.html"><strong aria-hidden="true">6.</strong> Взаимодействие с платформой</a></li><li class="chapter-item expanded "><a href="atoms.html"><strong aria-hidden="true">7.</strong> Работа с изменяемым состоянием</a></li><li class="chapter-item expanded "><a href="atoms_and_reactivity.html"><strong aria-hidden="true">8.</strong> Атомы и реактивность</a></li><li class="chapter-item expanded "><a href="complex_state.html"><strong aria-hidden="true">9.</strong> Сложное состояние</a></li><li class="chapter-item expanded "><a href="rum.html"><strong aria-hidden="true">10.</strong> Rum</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Astynax&#x27;s ClojureScript Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="clojure-что-это"><a class="header" href="#clojure-что-это">Clojure, что это</a></h1>
<h2 id="clojure-vs-clojurescript"><a class="header" href="#clojure-vs-clojurescript">Clojure VS ClojureScript</a></h2>
<p>В этой небольшой книге вы познакомитесь с языком Clojure в лице его диалекта ClojureScript. И, в отличие от пары совершенно разных языков Java и JavaScript, эти два языка по сути являются одним и отличаются только тонкостями интеграции с конкретной платформой: программы на Clojure запускаются на Java Virtual Machine, а программы на ClojureScript, скомпилированные в JavaScript выполняются в Web-браузере (или, к примеру, на NodeJS).</p>
<p>Тот факт, что языки семейства Clojure очень похожи между собой, означает, что и навыки при изучении вы получаете универсальные: если вам вдруг захочется после ClojureScript попробовать пописать на Clojure, вы будете чувствовать себя как дома! И по этой же причине вы, когда увидите в тексте упоминание Clojure, можете считать,   что упоминается всё семейство языков. А вот если будет упомянут именно ClojureScript, то это будет означать, что описывается какая-то особенность этой конкретной реализации.</p>
<h2 id="clojure--это-lisp"><a class="header" href="#clojure--это-lisp">Clojure — это Lisp</a></h2>
<p>Если вы когда-либо интересовались историей компьютерных наук, вы точно встречались с упоминанием семейства языков Lisp. А если даже история вас не слишком интересует, то само название вы наверняка слышали.</p>
<p>Семейство это старое и влиятельное. Сейчас трудно найти языки, авторы которых не вдохновлялись лиспами в той или иной степени. Тот же JavaScript изначально выглядел как ещё одна реализация Scheme, представителя одной из основных ветвей семейства лиспоподобных языков. И пусть в итоге JavaScript оказался синтаксически похож на Java, но внутри это до сих пор Lisp в овечьей шкуре.</p>
<p>Clojure визуально очень похож на другие лиспы, хотя ни в какие другие семейства не входит. Clojure, как всякий уважающий себя Lisp, имеет</p>
<ul>
<li>функции как сущности первого класса</li>
<li>упрощённый синтаксис, пригодный для программного манипулирования</li>
<li>систему метапрограммирования, также известную как &quot;макросы&quot;</li>
</ul>
<h2 id="Особенности-clojure"><a class="header" href="#Особенности-clojure">Особенности Clojure</a></h2>
<p>Автор Clojure Рич Хикки, создавая этот язык, выбрал для себя главной задачей борьбу со сложностью. В его понимании наиболее сложными концепциями — сложными для восприятия человеком и удержания в голове при работе с кодом — являются изменяемое состояние и одновременное исполнение нескольких подпрограмм. Кроме того в язык были заложены богатые средства для работы с данными и инструменты для взаимодействия с платформой. Рассмотрим же все эти составляющие &quot;образа языка&quot;.</p>
<h3 id="Изменяемые-данные"><a class="header" href="#Изменяемые-данные">Изменяемые данные</a></h3>
<p>Чтобы программист реже сталкивался с изменяемым состоянием, в мире Clojure в качестве основного подхода для решения задач используется функциональное программирование. Этот подход характерен использованием неизменяемых структур данных и чистых функций — таких функций, которые при вычислении результата не влияют на другие части программы и сами не зависят от того, в каком состоянии сейчас находится система.</p>
<p>Неизменяемые структуры данных подразумевают то, что когда вы &quot;меняете&quot; что-то в такой структуре, вы не затрагиваете оригинал, а вместо этого получаете новую структуру, содержащую нужные изменения. Чтобы такое поведение не приводило к ненужному перерасходу ресурсов машины, используются специальные <em>персистентные неизменяемые структуры данных</em>, которые в новых версиях данных используют повторно те части структуры, которые не менялись. Clojure, как типичный язык для &quot;в первую очередь функционального программирования&quot;, поддерживает такие структуры и умеет работать с ними эффективно.</p>
<h3 id="Одновременное-исполнение-подпрограмм"><a class="header" href="#Одновременное-исполнение-подпрограмм">Одновременное исполнение подпрограмм</a></h3>
<p>Сложность разработки программ, части которых работают одновременно, часто тоже связана с изменяемыми данными. Когда изменяемые данные доступны сразу нескольким <em>потокам</em> (они же <em>сопрограммы</em>, то есть программы, работающие сообща) и в любой момент времени могут быть изменены любым из них, часто практически невозможно предсказать то, как будет себя вести система в целом. Обычно программисты применяют специальные <em>примитивы синхронизации</em>, таких как semaphores и locks, чтобы управлять тем, какая из сопрограмм модифицирует данные в какой момент времени — и получают специфические для такого подхода проблемы вроде <em>блокировок</em> (<em>dead locks</em>) или <em>состояния гонки</em> (<em>race condition</em>).</p>
<p>Clojure наступает на класс проблем, связанных с многопоточностью, с двух фронтов:</p>
<ol>
<li>неизменяемые структуры данных позволяют сопрограмме не бояться за сохранность данных, пока она с этими данными работает;</li>
<li>высокоуровневые средства позволяют и вовсе обойтись без передачи нескольким сопрограммам данных, доступных для прямого изменения. Вместо этого вы связываете взаимодействующие сопрограммы, к примеру, <em>каналом</em>, который доставляет сообщения от одной стороны к другой.</li>
</ol>
<h3 id="Работа-с-данными"><a class="header" href="#Работа-с-данными">Работа с данными</a></h3>
<blockquote>
<p>Лучше иметь 100 функций, работающих с одной структурой данных, чем иметь 10 функций, работающих с 10 структурами данных.</p>
</blockquote>
<p>Алан Перлис так писал в своих &quot;Эпиграммах о программировании&quot; (1982). Эта цитата очень хорошо характеризует тот факт, что в языках семейства Lisp (название расшифровывается как &quot;List Processor&quot;!) принято на всё смотреть через призму списков. Список — великий уравнитель, и всё есть список, даже сам код на Lisp. Любые другие структуры данных реализуются с помощью <em>односвязных списков</em>, для работы с которыми лиспы обычно имеют богатейший набор инструментов.</p>
<p>С одной стороны наличие универсальной структуры &quot;под капотом&quot; у большинства других структур позволяет легко писать код, преобразующий одни данные в другие. А нужный уровень абстракции достигается предоставлением функций, при использовании которых вам не нужно знать, что внутри у данных списки списков списков. С другой стороны, как показывает многолетняя практика, некоторый набор структур общего назначения нужен настолько часто, что неплохо бы иметь эти структуры уже реализованными в языке и снабжёнными нужным количеством инструментов для работы с ними.</p>
<p>Получается, что полезно иметь &quot;штук пять структур с сотней функций для каждой&quot;! Недаром говорят:</p>
<blockquote>
<p>если нужно оставить только одну структуру данных, выбирай hash map</p>
</blockquote>
<p>Вот и Рич Хикки в дополнение к списку заложил в Clojure такие структуры как <em>отображение</em> (<em>map</em>), <em>множество</em> (<em>set</em>) и <em>вектор</em> (<em>vector</em>) и стандартная библиотека языка обладает множеством инструментов для работы с ними. И даже сам код на Clojure строится с использованием этих структур, а не одних лишь круглых скобок как в классических lisp.</p>
<h3 id="Взаимодействие-с-платформой"><a class="header" href="#Взаимодействие-с-платформой">Взаимодействие с платформой</a></h3>
<p>Clojure изначально создавался для запуска на Java Virtual Machine во многом потому, что платформа эта существует давно, а значит хорошо оптимизирована и &quot;обросла&quot; изрядным количеством библиотек, написанных для неё на Java и других языках, компилируемых в тот же формат байткода. Возможность легко подключить и использовать в своём коде сторонние библиотеки как правило требует от языка соответствующей поддержки.</p>
<p>Так как JVM исполняет код, который живёт в классах и оперирует объектами этих классов, то работать с классами нужно и со стороны Clojure/JVM. Более того, иногда нужно представить код, написанный на Clojure/JVM, в виде тех самых классов так, чтобы внешний код мог их использовать. Такая интеграция с платформой, работающая в обе стороны, называется <em>interoperability</em> или сокращённо <em>interop</em>.</p>
<p>У Clojure/JVM имеется хороший interop с JVM, а у ClojureScript — хороший interop с Browser API и NodeJS API. Благодаря тому, что использовать interoperability достаточно просто, многие популярные &quot;не родные&quot; библиотеки силами сообщества уже снабжены соответствующими &quot;обёртками&quot; и вам погружаться в interop не нужно.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Данные--код"><a class="header" href="#Данные--код">Данные == код</a></h1>
<h2 id="Данные--это-код"><a class="header" href="#Данные--это-код">Данные — это код</a></h2>
<p>Обычно в синтаксисе языка программирования присутствуют конструкции, отвечающие за описание значений встроенных типов. Такие конструкции называют <em>литералами</em>. Так числовые литералы описывают числа, а строковые — строки. Часто, если в языке есть встроенные структуры данных, в синтаксисе этого языка присутствуют и литералы для описания значений соответствующих типов. В JavaScript литералы объектов и массивов описывают объекты и массивы соответственно.</p>
<p>Поскольку литералы являются частью синтаксиса языка, то можно сказать, что любые описанные с помощью литералов <em>данные — это код</em>.</p>
<p>Однако, практически всегда синтаксис литералов является лишь небольшой частью синтаксиса всего языка. Вы просто не сможете описать, скажем, массив ключевых слов языка или добавить новый оператор в тело цикла: ключевые слова и управляющие инструкции не являются данными, доступными самому языку для манипулирования.</p>
<p>Иногда тот или иной язык предоставляет специальные средства для манипулирования собственным кодом — так называемые средства <em>метапрограммирования</em>. Но даже если язык и поддерживает метапрограммирование, то обычно манипулирование синтаксисом и манипулирование &quot;обычными&quot; данными — разные виде деятельности. И фаза манипулирования кодом, как правило, отделена от фазы его выполнения: сначала весь код приводится к окончательному виду, и только потом исполняется (возможно, предварительно компилируется).</p>
<h2 id="Код--это-данные"><a class="header" href="#Код--это-данные">Код — это данные</a></h2>
<p>В лиспоподобных языках для записи кода используются те же литералы, которые описывают данные. В классических лиспах вообще используется преимущественно одна структура данных — список. Любая программа состоит из списков и манипулирует списками же, а значит она может манипулировать собственным кодом. Получается, что в таких языках любой <em>код — это данные</em>!</p>
<p>Такое свойство языка, заключающееся в том, что и код и данные описываются одинаковым образом, называется <em>гомоиконичностью</em> (<em>homoiconicity</em>). При этом не важно, используется ли для описания любых значений одна структура данных или несколько. Важно лишь то, что любой код можно использовать ещё и как сложносоставное значение, которое можно преобразовывать силами языка и затем исполнять.</p>
<h2 id="Код-на-clojure-и-edn"><a class="header" href="#Код-на-clojure-и-edn">Код на Clojure и EDN</a></h2>
<p>Clojure — язык гомоиконичный. Подобно другим лиспам, язык использует списковые литералы для описания кода, но добавляет к ним ещё несколько структур, чтобы людям было проще этот код читать.</p>
<p>Кроме общего синтаксиса Clojure ещё существует его подмножество, называемое <em>EDN</em> — <em>Extensible Data Notation</em>. Это такой формат представления данных, который позволяет описать любые, понятные Clojure данные, но при этом не завязан именно на язык программирования. Можно сказать, что EDN относится к Clojure, как JSON относится к JavaScript — оба формата удобны для хранения и передачи данных, но могут быть и без каких-либо преобразований вставлены в код на соответствующем языке, где станут работать как литералы.</p>
<p>Поскольку код на Clojure практически полностью состоит из EDN, стоит начать знакомиться с синтаксисом EDN, а потом плавно перейти к специфичным именно для Clojure вещам.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Синтаксис-clojure"><a class="header" href="#Синтаксис-clojure">Синтаксис Clojure</a></h1>
<h2 id="read-eval-print-loop"><a class="header" href="#read-eval-print-loop">Read-Eval-Print Loop</a></h2>
<p>Пока мы будем рассматривать EDN и основы синтаксиса Clojure, вам стоит держать под рукой Clojure REPL. &quot;<em>REPL</em>&quot; — сокращение от &quot;Read-Eval-Print Loop&quot;. Это такая программа, которая позволяет вводить выражения на языке программирования, вычисляет их, печатает результат и ждёт следующей команды. У вас, скорее всего, уже имеется JavaScript REPL в вашем Web Browser, только называется он &quot;Консоль разработчика&quot; или как-то похоже.</p>
<p>Clojure — язык компилируемый, поэтому ему нужен компилятор, который пока в браузеры не встроили. Но на начальном этапе можно воспользоваться сайтом https://tryclojure.org — это как раз и есть &quot;Clojure REPL в браузере&quot;, реализованный с помощью ClojureScript. Можете попробовать ввести на сайте строчку <code>(println &quot;Hello world!&quot;)</code> и нажать <Enter>, в ответы вы должны получить соответствующее сообщение.</p>
<h2 id="Числа-строки-и-прочие-примитивы"><a class="header" href="#Числа-строки-и-прочие-примитивы">Числа, строки и прочие примитивы</a></h2>
<p>Числа в Clojure записываются так же, как в большинстве других языков: <code>42</code>, <code>3.14</code> — это целое число и число с плавающей точкой. Строки записываются в двойных кавычках: <code>&quot;Hello&quot;</code>.</p>
<p>Для булевых значений в языке имеются отдельные литералы: <code>true</code> и <code>false</code>, при этом булев в Clojure самостоятельный, а не является фасадом для чисел &quot;1&quot; и &quot;0&quot;, как бывает в некоторых языках.</p>
<p>Отдельно стоит отметить литерал, отвечающий за &quot;отсутствие значения&quot;, пусть даже сам по себе он значением является. Это литерал <code>nil</code>, по смыслу похожий на <code>null</code> в JavaScript. Если вы пробовали выполнить в REPL кусочек кода, упомянутый в предыдущем разделе, то вы видели вывод <code>nil</code> после приветствия: <code>nil</code> является результатом вычисления выражения <code>(println ...)</code>, потому что именно это значение вернула функция <code>println</code>.</p>
<h2 id="Ключевые-слова"><a class="header" href="#Ключевые-слова">Ключевые слова</a></h2>
<p><em>Ключевые слова</em> (<em>keywords</em>) — это имена, начинающиеся с двоеточия, и включающие в себя буквы, цифры и некоторые другие символы, такие как знак минуса. Ключевые слова ценны тем, что всегда представляют только самих себя, ни больше, ни меньше. Ключевое слово, сконструированное с помощью литерала или другим способом, всегда будет означать то же самое, что означают другие &quot;экземпляры&quot; этого ключевого слова когда бы и где бы вы их не создали. Поэтому keywords часто используются для описания каких-то <em>номинальных значений</em> вроде <code>:carrot</code> или <code>:city</code>. Вот ещё несколько примеров:</p>
<ul>
<li><code>:kebab-cased-name</code></li>
<li><code>:0xFF00FF</code> — нет, это не число!</li>
<li><code>:42</code> — и это не число</li>
<li><code>:/usr/local/bin/gzdoom</code> — а это не путь к файлу</li>
</ul>
<p>Попробуйте ввести каждый из этих символов в REPL и опробуйте заодно несколько своих keywords.</p>
<p>Вы можете спросить, а зачем нужен отдельный тип для &quot;просто имён&quot;. В других языках в роли таких &quot;просто каких-то имён&quot; часто используются строки. Вот только у этого решения есть недостатки. Так, две строки, созданные в разных частях программы, могут быть равны посимвольно, но чтобы удостовериться, что вы видите два экземпляра одной и той же сущности, вам придётся произвести это самое посимвольное сравнение. А ещё использование строк не только в роли текста, но и в роли &quot;имён общего назначения&quot; заставляет каждый раз, видя строковый литерал, думать, смотрите ли вы на текст или на другого рода значение — именно поэтому во многих руководствах по оформлению кода рекомендуется строковые константы не использовать как литералы, но сохранять предварительно в переменные (константные) и ссылаться на них по именам переменных.</p>
<p>Keywords, в отличие от &quot;строк как имён&quot;, не являются текстом, а значит нет никаких проблем с двойственностью &quot;текст VS имя&quot;. А ещё ключевые слова <em>быстро сравниваются</em> друг с другом: среда исполнения помнит все встреченные в коде ключевые слова и сравнивает их адреса в памяти вместо посимвольного сравнения имен.</p>
<h2 id="Символы"><a class="header" href="#Символы">Символы</a></h2>
<p><em>Символы</em> (<em>symbols</em>) похожи на ключевые слова, только они не предваряются двоеточием. И символы тоже что-то именуют. Но то, что в данном конкретном месте кода означает символ, всецело* зависит от контекста*: в одном месте имя может означать функцию, в другом строку, в третьем может не означать ничего, то есть будет <em>не определено</em>. Можете пока думать о символах, как об именах переменных и функций, потому что чаще всего символы именно в качестве таковых и используются.</p>
<p>Важно понять, что при вычислении выражений символ должен быть связан с чем-то, иначе вы получите ошибку &quot;Could not resolve symbol: XYZ&quot;. Чтобы использовать символ сам по себе, нужно его <em>процитировать</em> (<em>quote</em>), то есть добавить перед именем символ <code>'</code> (одинарная кавычка): так вы сообщите вычислителю, что вам важно само <em>имя символа</em>, а не значение, которое сейчас с именем связано. Вот несколько примеров символов, каждый из которых цитирован и может быть введён в REPL, где будет вычислен сам в себя:</p>
<ul>
<li><code>'hello</code></li>
<li><code>'/bin/bash</code></li>
</ul>
<h2 id="Векторы-и-отображения"><a class="header" href="#Векторы-и-отображения">Векторы и отображения</a></h2>
<p><em>Векторы</em> выполняют роль массивов из других языков — это упорядоченные наборы значений. К элементам векторов можно обращаться по индексу. Вот несколько примеров векторов:</p>
<ul>
<li><code>[]</code> — пустой вектор</li>
<li><code>[1 2 3]</code> — вектор чисел</li>
<li><code>[true false 3.14 nil [&quot;a&quot; 7]]</code> — вектор с элементами разных типов</li>
</ul>
<p><em>Отображения</em> (<em>maps</em>) выполняют роль хранилищ значений, доступных по ключу. Подобные структуры в других языках называются <em>словарями</em> или <em>хеш-таблицами</em>, а в JavaScript это объекты. Вот несколько примеров отображений:</p>
<ul>
<li><code>{}</code> — пустое отображение</li>
<li><code>{&quot;a&quot; 1 &quot;b&quot; 2}</code> — отображение, в котором по ключу <code>&quot;a&quot;</code> хранится значение <code>1</code>, а по ключу <code>&quot;b&quot;</code> значение <code>2</code></li>
<li><code>{1 &quot;a&quot; 2 &quot;b&quot;}</code> — а здесь уже ключами выступают числа, а значениями являются строки</li>
</ul>
<p>Заметьте, ни в векторах ни в отображениях <em>не используются запятые</em> для разделения элементов, а в отображениях даже ключи со значениями не связаны в пары никакими конструкциями, они просто идут друг за другом через одного. Единственный разделитель здесь, это пробел. И переносить на новую строку длинный литерал можно в любом месте, где имеется этот пробел. Да, к такому нужно привыкнуть. Но в целом такое <em>единообразие</em> записи литералов, как &quot;разделённых через пробелы последовательностей чего-то либо&quot;, позволяет меньше заботиться о синтаксисе и больше думать о сути.</p>
<p>Выше в примерах вы видели строки и числа в роли ключей, однако гораздо чаще вы будете встречать в роли ключей ключевые слова. Ведь что есть ключ отображения, как не &quot;имя значения&quot;? И как значения, ключевые слова тоже используются частенько. Вот вам пример структуры, описывающей группу домашних животных:</p>
<pre><code class="language-clojure">[{:type :pet  ; &lt;- тут и ключ, и значение это keywords
  :kind :dog  ; (к слову, с точки с запятой начинаются комментарии)
  :name &quot;Spike&quot;
  :age 3}
 {:type :pet
  :kind :cat
  :name &quot;Thomas&quot;
  :age 2}]
</code></pre>
<h2 id="Списки"><a class="header" href="#Списки">Списки</a></h2>
<p>У списков в Clojure роль особая. Как структура данных, односвязные списки подходят для не слишком широкого круга задач, поэтому именно в &quot;данных&quot; списки встретить можно довольно редко. А вот в &quot;коде&quot; списки превалируют: почти всегда, когда вы видите список, подразумевается <em>вызов функции</em> или другая <em>управляющая конструкция</em>, большая часть из которых — макросы, то есть, опять же, функции, только работающие с кодом. Вычислитель вообще всегда пытается трактовать литерал списка как вызов функции, если вы список предварительно не процитируете!</p>
<p>Вызов функции всегда выглядит как список, первый элемент которого вычисляется в функцию, а потом этой функции передаются остальные элементы списка в качестве аргументов. Чаще всего первым элементом будет выступать символ, который на момент вычисления связан со значением-функцией. Вот несколько примеров, опробуйте их в REPL:</p>
<ul>
<li><code>(println &quot;Hi!&quot;)</code></li>
<li><code>(+ 1 2)</code></li>
<li><code>(if (&gt; 2 1) :greater :not-greater)</code></li>
</ul>
<p>Заметьте, как выглядят сложение и сравнение чисел: оператор идёт перед операндами! Дело в том, что в лиспоподобных языках обычно нет такой вещи как &quot;оператор&quot;, есть только функции, связанные с символами <code>+</code>, <code>&gt;</code> и так далее. А поскольку имя функции всегда идёт первым в списке, то <code>+</code> в выражении, вычисляющем сумму, будет идти первым!</p>
<p>У такого единообразия трактовки функций есть рад преимуществ. Например, вам не нужно думать о приоритетах операторов, потому что перед вызовом функции всегда вычисляются её аргументы, поэтому выражение <code>(* (+ 5 7) 9)</code> вычисляется как &quot;(5 + 7) * 9&quot; и не нужно помнить, что в арифметике приоритет у умножения выше, чем у сложения.</p>
<p>Второе преимущество заключается в том, что у функций вроде <code>+</code> появляется возможность принимать больше (или меньше!) аргументов, чем бывает операндов у соответствующего оператора. Можно посчитать сумму пяти чисел одним вызовом функции сложения: <code>(+ 1 2 3 4 5)</code>. Или можно проверить, что все числа следуют друг за другом в порядке возрастания: <code>(&lt; 5 7 9)</code>. В частности, сравнение трёх аргументов можно часто встретить в ситуации, когда нужно проверить, входит ли число в интервал: <code>(if (&lt;= 0 x 10) :yes :no)</code> читается проще, чем <code>(if (and (&lt;= 0 x) (&lt;= x 10)) ...)</code>, не правда ли?</p>
<h2 id="Цитирование-и-децитирование"><a class="header" href="#Цитирование-и-децитирование">Цитирование и децитирование</a></h2>
<p>Цитирование уже упоминалось выше в разделе про символы как способ приостановить замену символа на связанное с ним значение. Но цитирование используется не только с символами, оно работает в любом месте кода и останавливает вычисление всего выражения, которое идёт следом за символом одиночной кавычки. Например, если вы введёте <code>'(+ 1 2)</code> в REPL, вы не получите тройку, вместо этого будет напечатан список из трёх элементов, первый из которых — символ &quot;+&quot;. Заметьте, именно символ, а не функция сложения, потому что замена имени на значение — тоже часть вычисления! Именно поэтому в цитате можно указывать символы, которые ещё не определены: <code>'(if foo (println bar) (explode))</code> — вы можете ввести это выражение в REPL и не получите в ответ сообщений о том, что &quot;foo&quot; и &quot;bar&quot; не определены.</p>
<p>Цитирование широко используется в метапрограммировании, потому что вам постоянно приходится приостанавливать вычисление, чтобы поработать со списками как с данными, а потом уже выполнять полученный код как обычно. Выполнение кода осуществляется вызовом функции <code>eval</code>, которая вычисляет то, что запретила вычислять кавычка, и <code>(eval '(+ 1 2))</code> вычислится в число &quot;3&quot;.</p>
<p>Попробуйте процитировать выражения разной вложенности и посмотрите, что выводится, если эти цитаты вычислить с помощью <code>eval</code>. Можете, скажем, поизучать выражение <code>'(+ (eval '(* 3 4)) 5)</code> — посмотрите, выполнится ли вложенный <code>eval</code> до того, как вы форсируете вычисление всей внешней цитаты?</p>
<p>В разделе, рассказывающем про списки, было сказано, что любой список трактуется как вызов функции, если литерал списка не процитировать. Но как быть, если список нужен как структура данных, но не хочется откладывать вычисление его элементов? Как, к примеру, получить именно список из чисел 1, 2 и 3 из литерала <code>'(1 (+ 1 1) 3)</code>, а не иметь <code>(+ 1 1)</code> вместо двойки? Если вы встретитесь с такой задачей, воспользуйтесь функцией <code>list</code>, которая создаёт список, но не вычисляет его как вызов функции, ведь она сама выступает в роли таковой: выражение <code>(list 1 (+ 1 1) 3)</code> вычислится в список <code>'(1 2 3)</code> — можете проверить в REPL.</p>
<h2 id="Определения"><a class="header" href="#Определения">Определения</a></h2>
<p><em>Определение</em> (<em>definition</em>) чего либо в Clojure — это связывание некоторого значения с именем. Именем всегда выступает символ, а вот значения могут быть самых разных типов. Самый простой вид определения — это определение константы, то есть единоразовое и постоянное связывание значения и имени. Выглядят такие определения следующим образом:</p>
<pre><code class="language-clojure">;; RGB-цвет, представленный как вектор из трёх чисел,
;; записанных в 16-ичной сисмете исчисления
(def fuchsia [0xFF 0x00 0xFF])

(def pi
  &quot;A number Pi&quot; ; это строка документации (docstring)
  3.1415926)    ; а это уже значение

;; документацию по символу можно посмотреть в REPL,
;; вызвав функцию (doc SYMBOL)
(doc pi)
(doc list)
</code></pre>
<p>Определения функций выглядят так:</p>
<pre><code class="language-clojure">(defn foo [x y]   ; параметры функции
  (+ x (* y 10))) ; x + y * 10
</code></pre>
<p>Заметьте, что <em>формальные параметры</em> функции описываются как вектор. А само определние выглядит как список, а точнее как вызов какой-то функции. Если вы тоже так подумали, то интуиция вас не подвела: такие определения функций являются вызовами — вызовами макроса <code>defn</code>, который преобразует примерно во что-то такое:</p>
<pre><code class="language-clojure">(def foo (fn [x y]
           (+ x (* y 10))))
</code></pre>
<p>Как видите, это тоже определение константы, только в виде значения выступает литерал, описывающий <em>анонимную функцию</em> или, как её ещё называют, &quot;лямбда-функцию&quot; или просто &quot;лямбду&quot; (название восходит к Лямбда-исчислению, это такая математическая модель).</p>
<p>Довольно часто в функциональном программировании вам требуется функция, которая нужна ровно в одном месте, и анонимные функции как раз в таких случаях и используюся. В некоторых языках именнованные функции и анонимные представлены разными сущностями. А в Clojure и здесь всё привычно единообразно: именованные функции — это всего лишь константы с анонимными функциями в роли значений.</p>
<p>Строго говоря, макрос <code>defn</code> не только переписывает определение, но и выполняет некоторые другие преобразования. Но пока мы их рассматривать не будем. Как только нам понядобятся специфичные возможности <code>defn</code>, о них будет рассказано.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Работа-с-данными-1"><a class="header" href="#Работа-с-данными-1">Работа с данными</a></h1>
<p>Литералы отображений, множеств и векторов вам уже знакомы. Они, можно сказать, описывают начальное состояние данных, но большая часть программ в процессе работы данные преобразует. Когда речь идёт о преобразовании неизменяемых структур данных, подразумевает создание новой версии данных без потери доступа к старой. Рассмотрим такой пример:</p>
<pre><code class="language-clojure">(def cart [{:type :apple :amount 3} {:type :orange :amount 1}])
;; =&gt; #'user/cart
</code></pre>
<blockquote>
<p>В этом примере, как и в последующих, комментарий вида &quot;<code>;; =&gt; …</code>&quot; показывает то, что выводит REPL в ответ на введённую команду. А конкретно <code>#'user/cart</code> означает квалифицированное имя определения, которое мы только что дали. Подробнее о таких именах мы поговорим позже. Сейчас вам достаточно запомнить, что в ответ на вычисление кода некоторого определения вы получаете только что определённое вами имя в качестве подтверждения.</p>
</blockquote>
<p>В данном определении описан вектор, представляющий список товаров в продуктовой корзине, и этот вектор связан с именем <code>cart</code>. У Clojure имеется универсальная функция &quot;добавления элемента&quot;, работающая с разными структурами данных. В случае вектора эта функция добавляет элементы в конец этого вектора:</p>
<pre><code class="language-clojure">(conj cart {:type :banana :amount 5})
;; =&gt; [{:type :apple, :amount 3} {:type :orange, :amount 1} {:type :banana, :amount 5}]
</code></pre>
<p>Всё верно, связка из пяти бананов попала в конец вектора и именно этот новый вектор из трёх элементов стал результатом вычисления вызова функции <code>conj</code>. Однако, если обратиться к определению <code>cart</code>, то окажется, что исходная корзина не изменилась:</p>
<pre><code class="language-clojure">cart
;; =&gt; [{:type :apple :amount 3} {:type :orange :amount 1}]
</code></pre>
<p>Как же работать с тем же продуктовыми корзинами, если однажды их создав, менять в них ничего не получится? Можно сохранять промежуточные результаты как <em>локальные определения</em>. Или сразу передавать следующей функции в качестве аргумента.</p>
<h2 id="Передача-состояния-между-функциями"><a class="header" href="#Передача-состояния-между-функциями">Передача состояния между функциями</a></h2>
<p>Предположим, что корзина покупок <code>cart</code> не отвечает изменившимся требованиям и теперь нам нужно убрать одно яблоко, добавить один апельсин и положить в корзину новый продукт — бутылку молока. Это три отдельных преобразования, каждое из которых вычисляет новую версию данных:</p>
<pre><code class="language-clojure">;; оригинальное состояние корзины:
;; [{:type :apple :amount 3} {:type :orange :amount 1}]
(conj
  (update-in
    (update-in
      cart
      [0 :amount] dec)
    [1 :amount] inc)
  {:type :milk :amount 1})
;; =&gt; [{:type :apple, :amount 2} {:type :orange, :amount 2} {:type :milk, :amount 1}]
</code></pre>
<p>Здесь функция <code>conj</code> вам уже знакома, она добавляет новый элемент в вектор. А функция <code>update-in</code> принимает в качестве аргументов</p>
<ul>
<li>структуру данных, с которой она будет работать,</li>
<li>&quot;путь&quot; до нужного элемента: вектор, содержащий индексы векторов и ключи отображений,</li>
<li>функцию, которая поменяет значение по указанному пути.</li>
</ul>
<p>В этом примере <code>(update-in cart [0 :amount] dec)</code> &quot;спускается&quot; вглубь <code>cart</code>, обращаясь сначала к первому элементу вектора — к отображению, а потом уже к значению ключа <code>:amount</code> внутри этого отображения. К значению, найденному в конце пути, применяется функция <code>dec</code>, которая осуществляет вычитание единицы.</p>
<blockquote>
<p>Функцию <code>update-in</code> можно было применить и так: <code>(update-in cart [0 :amount] - 1)</code> — здесь изменение будет осуществлять функция &quot;<code>-</code>&quot;, которая получит исходное значение в качестве первого аргумента и &quot;<code>1</code>&quot; в качестве второго. Проще говоря, аргументы &quot;<code>- 1</code>&quot; будут означать вычисление выражения <code>(- x 1)</code> с подстановкой исходного значения вместо &quot;x&quot;, а &quot;<code>dec</code>&quot; это всего лишь простейший случай вычисления <code>(dec x)</code>. Можно передавать и больше одного дополнительного аргумента для функции­модификатора: <code>(update-in ... + 1 2 3)</code></p>
</blockquote>
<p>Такой стиль программирования, когда вы данные пропускаете через конвейер, в котором в один момент времени с данными работает ровно один участок конвейера, называется &quot;Data Flow&quot;. Этот стиль достаточно популярен среди сторонников функционального программирования, так как хорошо сочетается с неизменяемыми структурами данных. И в целом читать код, не думая о том, что любой его фрагмент может менять состояние любых других участков кода, сильно проще.</p>
<h2 id="Локальные-определения"><a class="header" href="#Локальные-определения">Локальные определения</a></h2>
<p>Часто в процессе работы с какой-то сложной структурой данных или просто при выполнении многоступенчатого вычисления хочется временно некое промежуточное значение &quot;назвать&quot; и обращаться потом к значению по имени. Такие именования значений, актуальные лишь в рамках некоторого участка кода, называются <em>локальными определениями</em> и создаются с помощью конструкции <code>let</code>:</p>
<pre><code class="language-clojure">(let [a 100
      b (- a 13)
      c (* (/ a 2) b)]
  [a b c])
;; =&gt; [100 87 4350]
</code></pre>
<p>Структура конструкции <code>let</code> проста: сначала идёт символ <code>let</code>, следом вектор из последовательности чередующихся символов и сопоставляемых с ними значений, а затем так называемое &quot;тело&quot; — строчки кода, в которым будут доступны описанные опеределения.</p>
<blockquote>
<p>Если вы попробуете ввести данный пример в REPL на сайте try.clojure.org построчно, то интерпретатор после ввода первой строки выведет предупреждение о том, что во введённом коде не хватает каких-то закрывающих скобок. Однако, как только вы введёте выражение до конца, REPL сможет его вычислить. А вот если вы наберёте код в текстовом редакторе и вставите в REPL, то вставится код в виде одной длинной строчки. Результат вычисления при этом не изменится. Дело в том, что Clojure не увидит разницу, если вы введёте одной строчкой <code>(let [a 100 b (- a 13) …]…)</code> — переносы строк для Clojure равнозначны пробелам и взаимозаменяемы с оными. Этим удобно пользоваться именно в REPL, чтобы не видеть лишних предупреждений и иметь возможность редактирования кода до самого момента отправки его на вычисление.</p>
</blockquote>
<p>В рамках одной конструкции <code>let</code> последующим определениям доступны предыдущие, но не наоборот. Так в примере выше значение определения <code>b</code> будет зависеть от значения определения <code>a</code>, а определение <code>c</code> будет зависеть от обоих предшествущих. Это же справедливо и для обычных определений, сделанных с помощью <code>def</code>/<code>defn</code>.</p>
<p>А вот за пределами тела соответствующей конструкции <code>let</code> локальные определения видны не будут вовсе. Это, в частности, позволяет временно &quot;изменить&quot; значение какого-то определения, существующего на момент вычисления конструкции <code>let</code>, не затронув само оригинальное определение:</p>
<pre><code class="language-clojure">(def x 42)
;; =&gt; #'user/x
(let [x (+ x 1)  ; это вторая версия x,
      y (let [x (* x 2)]  ; а это уже третья версия x
          x)]
  [x y])
;; =&gt; [43 86]
x
;; =&gt; 42
</code></pre>
<h2 id="threading-macros"><a class="header" href="#threading-macros">Threading macros</a></h2>
<p>Если взять пример с модификацией корзины покупок и переписать с помощью локальных определений, то получится что-то такое:</p>
<pre><code class="language-clojure">(let [result (update-in cart [0 :amount] dec)
      result (update-in result [1 :amount] inc)
      result (conj result {:type :milk :amount 1})]
  result)
;; =&gt; [{:type :apple, :amount 2} {:type :orange, :amount 2} {:type :milk, :amount 1}]
</code></pre>
<p>В целом всё похоже на обычное использование вспомогательной переменной и <code>let</code> даже позволяет использовать одно и то же имя, так как каждое последующее определение &quot;затеняет&quot; (&quot;shadows&quot;) предыдущее. Однако даже для такой переменной нужно придумать имя и в целом код смотрится несколько громоздко. Зато сам порядок преобразований данных читается лучше, чем в оригинальном примере, в котором читать выражение нужно было, двигаясь мысленно изнутри наружу — именно в таком порядке вычисляются вложенные выражения.</p>
<p>К счастью, Clojure позволяет получить хорошо читаемый &quot;прямой порядок преобразований&quot; и при этом избежать введения лишних &quot;переменных&quot;:</p>
<pre><code class="language-clojure">(-&gt; cart
    (update-in [0 :amount] dec)
    (update-in [1 :amount] inc)
    (conj {:type :milk :amount 1}))
;; =&gt; [{:type :apple, :amount 2} {:type :orange, :amount 2} {:type :milk, :amount 1}]
</code></pre>
<p>Здесь <code>-&gt;</code>, это не функция, а макрос. А это означает, что код перед вычислением результата будет <em>преобразован</em>. Сейчас вы видите &quot;вызовы&quot; вида <code>(update-in [0 :amount] dec)</code>, которые выглядят как некорректные. Но дело тут в том, что макрос <code>-&gt;</code> <em>подставляет</em> результат вычисления предыдущего шага в качестве <em>первого аргумента</em> в последующий вызов и затем повторяет этот процесс. Макрос <code>-&gt;</code> делает подстановки, пока не преобразует весь &quot;список действий&quot; в обычное вложенное выражение, где каждый последующий шаг оборачивает предудущий.</p>
<p>Возможно такое преобразование именно потому, что код — это данные! Отдельные &quot;шаги&quot; в последовательности преобразований являются списками, да и сама последовательность — тоже список. Макрос <code>-&gt;</code> лишь перетасовывает список, подставляя одни элементы внутрь других.</p>
<p>На результат преобразований можно даже посмотреть, не производя сами вычисления. Делается это с помощью функции <code>macroexpand-1</code>. Этой функции нужно передать процитированный фрагмент кода и вы увидите то, во что этот код превратится после разворачивания первого слоя макросов. Вот что получится, если развернуть <code>-&gt;</code> в примере выше:</p>
<pre><code class="language-clojure">(macroexpand-1
  '(-&gt; cart
       (update-in [0 :amount] dec)
       (update-in [1 :amount] inc)
       (conj {:type :milk :amount 1})))
;; =&gt; (conj (update-in (update-in cart [0 :amount] dec) [1 :amount] inc) {:type :milk, :amount 1})
</code></pre>
<p>Получился такой же код, какой был в примере передачи результата из функции в функцию!</p>
<p>Благодаря макросу <code>-&gt;</code> и ему подобным цепочки преобразований данных писать становится очень просто — после того как вы к такому подходу привыкнете. А к хорошему привыкаешь быстро!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Инструментарий-разработчика"><a class="header" href="#Инструментарий-разработчика">Инструментарий разработчика</a></h1>
<h2 id="shadow-cljs"><a class="header" href="#shadow-cljs">Shadow-ClJS</a></h2>
<p>REPL в браузере хорош для первого знакомства с языком, однако с его помощью не получится заниматься непосредственно разработкой. Чтобы разрабатывать реальные проекты на ClojureScript, вам потребуются установленные на вашей ваш компьютер компилятор ClojureScript в JavaScript, инструмент для управления зависимостями (сторонними библиотеками), REPL.</p>
<p>Сейчас все эти задачи берёт на себя инструмент под названием <strong>Shadow-ClJS</strong>. Вы можете найти этот проект по ссылке: https://github.com/thheller/shadow-cljs Самый простой способ установки shadow-cljs, который при этом подходит для большинства пользователей — это генерация проекта с помощью следующей команды:</p>
<pre><code class="language-shell">$ npx create-cljs-project hello
...
</code></pre>
<p>Эта команда создаст директорию с именем &quot;hello&quot; и заполнит необходимым минимумом файлов, среди которых наиболее интересен <code>shadow-cljs.edn</code> — основной файл настройки того, как будет компилироваться ваш проект.</p>
<p>После того, как <em>npx</em> закончит подготавливать проект, вы сможете запустить REPL.</p>
<h2 id="repl"><a class="header" href="#repl">REPL</a></h2>
<p>Компилятор ClojureScript сам по себе является программой, написанной на Clojure и запускается на Java Virtual Machine. Но код на языке JavaScript, которые появляется в результате компиляции ClojureScript­кода, тоже нужно на чём-то запускать — нужна среда исполнения JavaScript. Таковых обычно имеется две на выбор: NodeJS и Web-браузер. REPL, использующий NodeJS для выполнения JavaScript, запускается командой</p>
<pre><code class="language-shell">$ npx shadow-cljs node-repl
</code></pre>
<p>Этот REPL максимально похож на тот, что вы видели на странице Try.Clojure. Вы можете вводить код и видеть результат его выполнения в вашем окне терминала.</p>
<p>REPL, исполняющий JS силами Web­браузера, запускается командой</p>
<pre><code class="language-shell">$ npx shadow-cljs browser-repl
shadow-cljs - config: /home/astynax/Projects/cljs/hello/shadow-cljs.edn
shadow-cljs - server version: 2.20.17 running at http://localhost:9630
shadow-cljs - nREPL server started on port 37463
[:browser-repl] Configuring build.
[:browser-repl] Compiling ...
</code></pre>
<p>После того, как вы запустите эту команду, через какое-то время ваш браузер откроет страницу с текстом &quot;Code entered in a browser-repl prompt will be evaluated here.&quot;. При этом в окне терминала вы всё так же будете видеть так называемое <em>приглашение</em> &quot;<code>cljs.user=&gt;</code>&quot; и сможете вводить код.</p>
<blockquote>
<p>Если окно браузера на открывается автоматически, то вы можете вручную открыть в браузере адрес http://localhost:9630 (номер порта может отличаться, нужный вам вы найдёте среди сообщений, выводимых в терминале — ищите строчку с текстом &quot;server … running at …&quot;).</p>
</blockquote>
<p>Browser REPL является основным, когда вы разрабатываете Web­приложения для браузера. При этом вам доступны многие привычные для Web­разработчика функции, только видите вы их в обёртке ClojureScript. Например, если ввести в ответ на приглашение строчку <code>(js/alert &quot;Hello!&quot;)</code>, то браузер покажет модальное окно с соответствующим сообщением. А если ввести <code>(.log js/console &quot;ping&quot;)</code>, то сообщение уже будет выведено в консоль <em>инструментария разработчика</em> — опять же, в окне браузера.</p>
<h2 id="Первый-код"><a class="header" href="#Первый-код">Первый код</a></h2>
<p>Сгенерированный проект содержит поддиректории <code>src/main</code> и <code>src/test</code>, в которых и принято размещать код и тесты к нему. Код на языке Clojure хранится в файлах, каждый из которых описывает <em>пространство имён</em> (в других языках эти файлы могут называется &quot;модулями&quot;), при этом и файлы, и пространства имён называются в соответствии с соглашением <em>Java Naming Conventions</em>. И как бы нам не хотелось назвать файл просто <code>app.cljs</code>, следует придумать более уникальное и &quot;говорящее&quot; имя вида &quot;company.project.name&quot;.</p>
<p>Создайте файл <code>src/main/com/frontend/app.cljs</code> со следующим содержимым:</p>
<pre><code class="language-clojure">(ns com.frontend.app)

(defn init []
  (js/alert &quot;Hello World!&quot;))
</code></pre>
<p>Чтобы компилятор смог найти этот файл и использовать функцию <code>init</code> как точку входа в программу (вызывать эту функцию при показе Web­страницы), нужно модифицировать <code>shadow-cljs.edn</code>. Нужно изменить значение ключа <code>:builds</code> так, чтобы оно выглядело следующим образом:</p>
<pre><code class="language-edn">{
...

:builds
{:frontend
  {:target :browser
   :modules {:main {:init-fn com.frontend.app/init}}
   }}
}
</code></pre>
<p>Компилятор помещает полученный JavaScript­код в файл <code>publis/js/main.js</code>. А чтобы браузер мог этот файл загрузить, вам понадобится HTML­страница <code>public/index.html</code> следующего вида:</p>
<pre><code class="language-html">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;body&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;/js/main.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>И, наконец, нужно включить HTTP­server, встроенный в Shadow-ClJS, чтобы тот мог отдавать браузеру файлы. В <code>shadow-cljs.end</code> нужно добавить следующее:</p>
<pre><code class="language-edn">{
...
:dev-http {8080 &quot;public&quot;} ; &lt;- порт и директория

:builds
{...}

}
</code></pre>
<p>Теперь, если вы запустите shadow-cljs в &quot;режиме разработки&quot; командой</p>
<pre><code class="language-shell">$ npx shadow-cljs watch frontend
...
shadow-cljs - HTTP server available at http://localhost:8080
</code></pre>
<p>Теперь компилятор будет собирать новый JS­файл в ответ на каждое изменение ClojureScript­кода, после чего останется только обновить страницу в браузере! А если вы откроете в браузере адрес http://localhost:8080 то будет вызвана та самая функция <code>init</code> и браузер покажет модальное окно с сообщением.</p>
<p>Важное свойство &quot;режима разработки&quot; заключается в том, что каждое изменение кода после компиляции оного (успешной, разумеется) загружается в браузер автоматически. Это обычно означает, что вам не нужно перезагружать страницу каждый раз, когда вы вносите изменения в код на ClojureScript. Более того, есть способы <strong>сохранить текущее состояние приложения</strong>, даже если логика его работы периодически меняется!</p>
<h3 id="server-watch-cljs-repl"><a class="header" href="#server-watch-cljs-repl">server, watch, cljs-repl</a></h3>
<p>Режим &quot;watch&quot;, он же &quot;режим разработки&quot; всем хорош, кроме того, что вы не имеете возможность коммуницировать с REPL, а можете только редактировать код, который затем загружается в браузер. Но иногда всё же хочется иметь возможность повзаимодействовать с приложением в интерактивном режиме.</p>
<p>Часто такую возможность даёт ваш редактор — если он умеет работать с Clojure и ClojureScript. Для таких редакторов Shadow ClJS предоставляет доступ к так называемому протоколу &quot;nREPL&quot;, поэтому при старте <code>shadow-cljs</code> вы видите сообщение вида &quot;nREPL server started on port …&quot;. Если же вам хочется запускать REPL вручную из терминала, лучше сразу запускать shadow-cljs в <em>режиме сервера</em> командой</p>
<pre><code class="language-shell">$ npx shadow-cljs server frontend
...
shadow-cljs - HTTP server available at http://localhost:8000
shadow-cljs - server version: 2.20.17 running at http://localhost:9630
shadow-cljs - nREPL server started on port 43035
</code></pre>
<p>HTTP­server будет запущен, так что открыть страницу в браузере вы сможете. Но горячая загрузка кода пока не будет работать.</p>
<p>Теперь, уже в другом окне терминала вам нужно запустить ещё один экземпляр Shadow в режиме <code>watch</code> и этот новый экземпляр подключится к уже запущенному серверу:</p>
<pre><code class="language-shell">$ npx shadow-cljs watch frontend
...
shadow-cljs - connected to server
shadow-cljs - watching build :frontend
</code></pre>
<p>В этот момент заработает горячая перезагрузка кода.</p>
<p>Чтобы запустить REPL, вам потребуется третье окно терминала, в котором следует вызвать команду:</p>
<pre><code class="language-shell">$ npx shadow-cljs cljs-repl frontend
...
shadow-cljs - connected to server
cljs.user=&gt;
</code></pre>
<p>Вот и REPL, который работает в связке с браузером, а значит можно с оным пообщаться:</p>
<pre><code class="language-clojure">cljs.user=&gt; (js/alert &quot;Ping!&quot;)
nil
</code></pre>
<p>Чтобы получить доступ к коду, который мы написали в модуле <code>app.cljs</code>, вам нужно в REPL &quot;переключиться&quot; на соответствующее пространство имён — то, которое мы указали в форме <code>(ns ...)</code>:</p>
<pre><code class="language-clojure">cljs.user=&gt; (in-ns 'com.frontend.app)  ;; имя процитировано!
com.frontend.app=&gt; (init)  ;; теперь функция init видна
nil
</code></pre>
<p>Узнайте, как в вашем любимом редакторе обстоят дела с поддержкой Clojure nREPL. Многие редакторы позволяют подключиться к <em>nREPL server</em> напрямую, так что отдельно запускать REPL вам не придётся. Однако знать о такой возможности полезно, поэтому она здесь и упомянута.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Взаимодействие-с-платформой-1"><a class="header" href="#Взаимодействие-с-платформой-1">Взаимодействие с платформой</a></h1>
<p>ClojureScript компилируется в JavaScript и выполняется в браузере. Это означает, что либо стандартная библиотека языка должна иметь все средства для взаимодействия с браузером, либо язык должен предоставлять удобные средства для взаимодействия со средой исполнения JavaScript. Язык Clojure в целом следует второму пути и ClojureScript в частности позволяет вашему коду общаться с браузером посредством уже имеющегося JavaScript API.</p>
<p>Теперь, когда у вас уже есть настроенный проект, можно начать применять ClJS на практике. Реализуем приложение, которое бы при загрузке страницы модифицировало содержимое оной. В <code>index.html</code> уже имеется тег <code>&lt;div id=&quot;root&quot;&gt;</code>, его содержимое мы и будем менять. В файле <code>src/main/com/frontend/app.cljs</code> (в ближайшее время весь код будет относиться к этому файлу) опишите функцию следующего вида:</p>
<pre><code class="language-clojure">(defn update []
  (-&gt; (.querySelector js/document &quot;#root&quot;)
      .-innerHTML
      (set! &quot;&lt;h1&gt;Hello World!&lt;/h1&gt;&quot;)))
</code></pre>
<p>Здесь используются сразу три вида взаимодействия с JavaScript objects:</p>
<ol>
<li><code>(.querySelector js/document &quot;#root&quot;)</code> — это вызов метода <code>querySelector</code> применительно к объекту <code>document</code> со строкой <code>&quot;#root&quot;</code> в качестве аргумента. Такой вызов в JavaScript выглядел бы как строчка <code>document.querySelector(&quot;#root&quot;)</code>.</li>
<li><code>(.-innerHTML node)</code> — обращение к атрибуту объекта, эквивалентное выражению <code>node.innerHTML</code> в JS.</li>
<li><code>(set! value attribute)</code> — присвоение нового значения атрибуту объекта. В JS это выглядело бы как <code>object.attribute = value</code>.</li>
</ol>
<blockquote>
<p>В примере выше обращение к полю не обёрнуто в скобки, поскольку макрос <code>-&gt;</code> позволяет опускать оные, если на текущем шаге конвейера нужно применить функцию к одному лишь передаваемому по конвееру аргументу. С тем же успехом можно было написать <code>(-&gt; .. (.-innerHTML) ..)</code>, но макрос <code>-&gt;</code> позволяет слегка сэкономить на скобках. И возможно такое упрощение потому, что обращение к атрибуту — тоже функция. Сам же макрос <code>-&gt;</code> ничего не знает об объектах и атрибутах!</p>
</blockquote>
<p>Теперь, когда у вас есть функция <code>update</code>, её можно вызвать из &quot;точки входа в программу&quot; — из функции <code>init</code>:</p>
<pre><code class="language-clojure">(defn init []
  (update))
</code></pre>
<p>Попробуйте открыть страницу при запущенном dev server, вы должны увидеть вставленный в тело страницы тег <code>h1</code> с текстом приветствия.</p>
<p>Вот ещё несколько примеров использования JS interoperability:</p>
<pre><code class="language-clojure">(defn log-some-date []
  (let [date (js/Date. 1999 12 31)]  ;; создание объекта
    (.log js/console (.toISOString date))))  ;; вызовы методов
</code></pre>
<p>Здесь <code>(js/Date. ...)</code>, это аналог создания нового объекта типа <code>Date</code>. В JavaScript вы бы написали <code>new Date(...)</code>. Заметьте: точка в конце имени типа означает, что вы вызываете конструктор данного типа, без точки вы бы получили доступ к самому классу <code>js/Date</code>, который не может быть вызван как функция сам по себе.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Работа-с-изменяемым-состоянием"><a class="header" href="#Работа-с-изменяемым-состоянием">Работа с изменяемым состоянием</a></h1>
<p>Практически любое приложение меняет своё состояние в процессе работы. В JavaScript состояние хранится в глобальных переменных, в лексических замыканиях, в атрибутах объектов. ClojureScript, как hosted язык, тоже может создавать JS­объекты и изменять их содержимое в процессе работы программы. Однако, в мире JavaScript достаточно часто эти объекты, изображающие фрагменты одного большого &quot;состояния всей системы&quot;, изменяются разными частями программы и уследить за всеми изменениями бывает достаточно сложно, если вообще возможно. Поэтому в Clojure используются неизменяемые структуры данных, доступ к которым осуществляется через <em>изменяемые ссылки</em>.</p>
<h2 id="Атомы"><a class="header" href="#Атомы">Атомы</a></h2>
<p>В Clojure существует несколько видов изменяемых ссылок, обладающих различными свойствами, однако в ClojureScript доступен ровно один вид: <em>атомы</em>. В процессе работы с атомом мы получаем текущее значение по ссылке, создаём новое значение на основе старого и только после этого перенаправляем ссылку на это новое значение. При этом непосредственно изменение ссылки происходит мгновенно, насколько сильно бы мы не меняли само значение. Поэтому не возникает печально известное <em>состояние гонки</em>, когда часть данных уже поменялась, а часть ещё не успела измениться и какие-то другие процессы в программе могут получить доступ к <em>неконсистентному состоянию</em>. При использовании атомов по ссылке всегда доступно либо старое состояние, либо уже новое, никакой возможности получить частично изменённые данные нет!</p>
<p>Создаётся атом функцией <code>(atom начальное-значение)</code> и обычно связывается с некоторым именем:</p>
<pre><code class="language-clojure">(def counter (atom 0))
</code></pre>
<p>Получить текущее значение, на которое ссылается атом, можно с помощью так называемого <em>разыменования</em> (<em>dereferencing</em>), указав перед именем символ <code>@</code>: <code>(println @counter)</code>. При разыменовывании вы получаете именно текущее значение, поэтому булево выражение <code>(= @counter @counter)</code> иногда может оказаться ложным — если другая часть программы успеет изменить ссылку между двумя разыменованиями.</p>
<p>И, наконец, перенаправить ссылку на новое значение можно с помощью функции <code>(reset! имя-атома новое-значение)</code>.</p>
<blockquote>
<p>Заметьте, функция <code>set!</code>, изменяющая значение атрибутов JS­объектов, и функция <code>reset!</code>, перенаправляющая ссылки атомов, имеют восклицательные знаки в именах. Так в Clojure принято называть функции, за использованием которых нужно внимательно следить. Как правило, это функции, меняющие что-то за пределами видимости текущего участка кода.</p>
</blockquote>
<h2 id="reset-против-swap"><a class="header" href="#reset-против-swap"><code>reset!</code> против <code>swap!</code></a></h2>
<p>У функции <code>reset!</code> есть один недостаток: если вы разыменовали атом, долго вычисляли новое значение, а потом перенаправили на него атом с помощью <code>reset!</code>, то может так случиться, что какой-то другой процесс успеет изменить атом после вашего разыменования, но до вашего <code>reset!</code>. Если такое случится, то часть информации будет потеряна. Вот так эта ситуация может выглядеть:</p>
<pre><code class="language-clojure">;; [ первый процесс ]                | ;; [ второй процесс ]
;;                                   | ;;
;; получаем текущий баланс счёта     | ;;
(let [acc @bob-account]              | ;;
  ;; что-то долго делаем             | (let [acc @bob-account]
  ;; ...                             |   ;; быстро снимаем 10 кредитов
  ;; ...                             |   (reset! bob-account (- acc 10)))
  ;; списываем 100 кредитов          | ;;
  (reset! bob-account (- acc 100)))  | ;;
</code></pre>
<p>Здесь первый процесс даже не узнает о том, что баланс счёта уже поменялся на -10 кредитов, и перезапишет с расходом -100 кредитов, а первые -10 потеряются!</p>
<p>Чтобы попадать в такие ситуации пореже, обычно стараются разыменовывать атомы максимально близко к вызову <code>reset!</code>. Однако есть более безопасный способ: функция <code>swap!</code>. Эта функция не принимает новое значение для атома, а вместо этого ожидает, чтобы вы предоставили ей <em>функцию из старого значения в новое</em>. При этом само внутреннее устройство атома гарантирует, что при вызове такой <em>функции­модификатора</em> между получением старого значения и переключением ссылки на новое никакой другой процесс не вклинится. То есть использование <code>swap!</code> делает изменение истинно <em>атомарным</em> (именно поэтому атомы называются так как называются).</p>
<p>Чтобы списать со счёта Боба десять кредитов, нужно применить <code>swap!</code> таким образом: <code>(swap! bob-account - 10)</code> — значение по ссылке будет передано в функцию­модификатор первым, но вы можете указать и другие аргументы для функции. Таким образов в одной части программы можно сделать <code>(swap! bob-account - 100)</code>, а в другой выполнить <code>(swap! bob-account - 10)</code>, и общие траты составят -110!</p>
<h2 id="Атомарность-и-побочные-эффекты"><a class="header" href="#Атомарность-и-побочные-эффекты">Атомарность и побочные эффекты</a></h2>
<p>Функция <code>swap!</code> устроена так, что при перед вызовом функции­модификатора запоминает старый адресат ссылки. А после того, как модификатор вернул новое значение, то <code>swap!</code> проверяет, указывает ли ссылка на запомненный ранее адрес. Если ссылка оказалась перенаправлена, пока модификатор выполнял вычисления, то <code>swap!</code> запускает модификатор ещё раз — уже с новым значением (тем, на которое теперь указывает ссылка) в качестве аргумента.</p>
<p>Такие повторы могут происходить не единожды, если с атомом одновременно и достаточно активно работают несколько процессов в рамках одной программы. Поэтому очень важно не производить в теле функции­модификатора никакие побочные эффекты вроде изменения других атомов, отправки запросов к серверу и тому подобные действия. Иначе вы рискуете ощутить эти побочные эффекты несколько раз, даже если сделали один вызов <code>swap!</code>.</p>
<p>Рекомендация тут может быть такая: вам нужно выносить любые затратные с точки зрения времени или сопряжённые с побочными эффектами вычисления за пределы функции­модификатора, а <code>swap!</code> использовать только в самом конце. Следовать этой рекомендации обычно не слишком сложно, и отделение побочных эффектов от изменения состояния идёт на пользу читаемости кода.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Атомы-и-реактивность"><a class="header" href="#Атомы-и-реактивность">Атомы и реактивность</a></h1>
<p>У атомов в Clojure есть ещё одна особенность, которая очень полезна при разработке Web­приложений: вы можете <em>подписаться</em> на изменения атома и, к примеру, своевременно обновлять пользовательский интерфейс.</p>
<p>Добавим в наше приложение атом, который будет хранить значение некоего счётчика:</p>
<pre><code class="language-clojure">(ns ...)

;; атомы часто располагают в начале модуля
(defonce counter (atom 0))

...
</code></pre>
<p>Здесь используется <em>форма</em> <code>defonce</code>, которая похожа на обычное объявление с помощью <code>def</code>. Отличается <code>defonce</code> от <code>def</code> тем, что при горячей перезагрузке кода (которую производит Shadow ClJS в &quot;режиме разработки&quot;) значение такого объявления не изменяется.</p>
<p>Это достаточно удобно — не терять состояние приложения при перезагрузке кода. Однако нужно понимать, что иногда состояние приходится таки сбрасывать, например если поменялась сама структура того, как данные должны в этом конкретном атоме храниться. В таких случаях вы можете перезагрузить страницу целиком или же в REPL вызвать <code>reset!</code>, перенаправив таким образом атом на новое, корректное значение.</p>
<h2 id="Подписка-на-изменения"><a class="header" href="#Подписка-на-изменения">Подписка на изменения</a></h2>
<p>Чтобы наше приложение начало реагировать на изменения атома <code>counter</code>, нужно оформить подписку. Проще всего подписываться на атомы в функции, которая выступает как точка входа. В нашем случае это <code>init</code>:</p>
<pre><code class="language-clojure">(defn init []
  (draw @counter)  ;; первый раз draw вызывается принудительно
  (add-watch counter  ;; атом, на который оформляется подписка
             :draw    ;; &quot;ключ&quot;, идентифицирующий подписку
             (fn [_ _ _ value]  ;; функция-обработчик изменений
               (draw value))))
</code></pre>
<p>Ключ здесь нужен для того, чтобы функция­обработчик могла отличать один атом от другого, если эта функция оказывается подписана на несколько атомов.</p>
<p>Сейчас в роли обработчика выступает анонимная функция. И как любой обработчик, функция эта получает при вызове четыре аргумента:</p>
<ol>
<li>сам атом,</li>
<li>упомянутый выше ключ,</li>
<li>значение, на которое атом указывал ранее,</li>
<li>значение, на которое атом указывает сейчас</li>
</ol>
<blockquote>
<p>В примере выше нам интересно только новое значение, поэтому остальные параметры функции­обработчика названы именем <code>_</code>. Это общепринятый способ называть аргументы, наличия которых требует вызывающая сторона, а самой функции эти параметры не важны.</p>
</blockquote>
<p>В данный момент обработчик вызывает функцию <code>draw</code> с текущим значением счётчика в качестве аргумента. И принудительный вызов <code>(draw @counter)</code> в начале работы программы тоже передаёт значение счётчика в функцию <code>draw</code> Нужно изменить функцию так, чтобы она имела соответствующий параметр и отображала передаваемые ей значения:</p>
<pre><code class="language-clojure">(defn draw [value]
  (-&gt; (.querySelector js/document &quot;#root&quot;)
      .-innerHTML
      (set! (str &quot;&lt;h1&gt;&quot; value &quot;&lt;/h1&gt;&quot;))))
</code></pre>
<blockquote>
<p>Функция <code>str</code> конкатенирует все свои аргументы в одну строку, приводя к строке значения других типов, если таковые встречаются.</p>
</blockquote>
<p>Если теперь обновить страницу, или вызвать <code>(init)</code> в REPL, то страница должна показать начальное значение счётчика — &quot;0&quot;. И если в REPL увеличить значение счётчика с помощью вызова <code>(swap! counter inc)</code>, то текст на странице также изменится и произойдёт это автоматически — благодаря подписке.</p>
<h2 id="Реакция-на-перезагрузку-кода"><a class="header" href="#Реакция-на-перезагрузку-кода">Реакция на перезагрузку кода</a></h2>
<p>Стоит добавить ещё один кусочек реактивности в приложение: научить его реагировать на горячую загрузку кода. Для этого достаточно описать функцию и добавить ей определённый флаг в качестве <em>метаданных</em>:</p>
<pre><code class="language-clojure">(defn ^:dev/after-load redraw []
  (draw @counter))
</code></pre>
<p>Здесь <code>^:dev/after-load</code> означает &quot;дописать к метаданным функции redraw значение <code>true</code> по данному ключу&quot;. Дело в том, что метаданные хранятся в виде отображения. Но часто важно именно наличие ключа, а само значение не существенно. Поэтому для такого случая разрешён укороченный вариант записи. Если вдруг вам будет интересно, можете запросить в REPL метаданные для функции redraw:</p>
<pre><code class="language-clojure">com.frontend.app&gt; (meta #'redraw)
;; =&gt; {:ns com.frontend.app,
 :name redraw,
 :file &quot;com/frontend/app.cljs&quot;,
 ...
 :dev/after-load true,  ; вот и флаг!
 ... }
</code></pre>
<p>Метаданные широко используются в самых разных задачах. Метаданные объявляемых функций описывают, в каком файле какая функция была объявлена, с какой и по какую строчку это объявление в файле располагается и тому подобное. В данном же примере Shadow ClJS по наличию этого флага узнаёт, что данную функцию нужно вызывать каждый раз сразу после загрузки новой версии кода.</p>
<blockquote>
<p>В Clojure метаданные можно добавлять практически к любому значению за исключением <em>примитивных типов</em> вроде строк или чисел. Для этого используется функция <code>(with-meta значение {:ключ :значение ...})</code>. И даже <code>defn</code> в реальности представляет собой макрос, который связывает символ имени с анонимной функцией, попутно с помощью <code>with-meta</code> добавляя к ссылке на функцию порцию метаданных.</p>
</blockquote>
<h2 id="Интерактивность"><a class="header" href="#Интерактивность">Интерактивность</a></h2>
<p>На внешние воздействия счётчик уже реагирует, теперь нужно добавить пару кнопок, чтобы и пользователь приложения мог менять значение счётчика. Пока что мы описываем теги в виде строковых литералов, поэтому <code>&lt;button&gt;</code> пока будут получать обработчики нажатия в атрибуте <code>onclick</code>. А это значит, что в качестве значения атрибута будет выступать код на JavaScript, пусть даже мы и хотим вызывать функции, которые напишем на Clojure. Впрочем, так мы сможем увидеть ещё один вид взаимодействия ClJS с платформой: вызов функций из мира ClojureScript в коде на JavaScript.</p>
<p>Так как проект сейчас имеет всего один модуль, описывающий пространство имён <code>com.frontend.app</code>, то все определения, описанные в этом модуле, будут видны со стороны JavaScript как атрибуты объекта <code>app</code>, являющегося атрибутом объекта <code>frontend</code>, являющегося атрибутом объекта <code>com</code>, который, наконец, является атрибутом глобального объекта <code>document</code>. Другими словами уже имеющаяся у нас функция <code>init</code> может быть вызвана в коде на JavaScript по полному имени: <code>com.frontend.app.init()</code> — всё настолько просто! Разве что имена, которые по­лисповски названы в стиле <code>kebab-case</code>, со стороны JS будут выглядеть как <code>snake_case</code>.</p>
<p>Добавим сразу обе функции, которые будут обрабатывать нажатия кнопок, и модифицируем функцию <code>draw</code> так, чтобы кнопки встраивались в вёрстку:</p>
<pre><code class="language-clojure">(defn inc-counter [] (swap! counter inc))
(defn dec-counter [] (swap! counter dec))

(defn button [text action]
  (str &quot;&lt;button onclick=\&quot;&quot;
       (-&gt; action
           .-name
           (clojure.string/replace &quot;$&quot; &quot;.&quot;))
       &quot;()\&quot;&gt;&quot;
       text
       &quot;&lt;/button&gt;&quot;))

(defn draw [value]
  (-&gt; (.querySelector js/document &quot;#root&quot;)
      .-innerHTML
      (set! (str &quot;&lt;h1&gt;&quot;
                 value
                 (button &quot;+&quot; inc-counter) ; вот и кнопки
                 (button &quot;-&quot; dec-counter)
                 &quot;&lt;/h1&gt;&quot;))))
</code></pre>
<p>Сами обработчики устроены просто: они всего лишь обновляют атом с помощью функций <code>inc</code> и <code>dec</code> (увеличение и уменьшение на единицу, соответственно).</p>
<p>В <code>draw</code> тоже добавились только два вызова функции <code>button</code>. Каждый раз в функцию передавались строка и функция, тоже с виду всё просто.</p>
<p>А вот функция <code>button</code> интересна тем, как она работает со значениями своего параметра <code>action</code>. В качестве значений этот параметр получает функции на ClojureScript, но в HTML­то нужно вставить правильные имена  JavaScript­объектов, в которые эти функции будут скомпилированы!</p>
<p>К счастью, каждая скомпилированная функция получает имя, составленное из полного имени пространства имён плюс имени функции, только в этом имени все точки заменяются на &quot;<code>$</code>&quot;, а все дефисы — на символ &quot;<code>_</code>&quot;. И сохраняется это имя в атрибуте <code>.name</code> объекта. Нам остаётся только извлечь значение атрибута, заменить в нём <code>$</code> обратно на <code>.</code>, и мы получим &quot;внешнее имя&quot;: &quot;<code>com$frontend$app$inc_counter</code>&quot; превратится в &quot;<code>com.frontend.app.counter</code>&quot;. Такое преобразование и выполняется выше в коде функции <code>button</code>.</p>
<h2 id="Подведём-итоги"><a class="header" href="#Подведём-итоги">Подведём итоги</a></h2>
<p>Итак, теперь приложение стало по-настоящему интерактивным: кнопки можно нажимать, нажатия изменят состояние приложения, интерфейс прореагирует на изменения — цикл замкнулся, любые более сложные приложения реализуются похожим образом... или нет?</p>
<p>Вы, наверняка, подумали, что работать этими &quot;внутренними&quot; и &quot;внешними&quot; именами функций утомительно и склеивание строк не выглядит как надёжный и быстрый способ наполнить страницу. Да, можно заменить склеивание строк на создание и вставку элементов DOM. И вместе с этим перейти от назначения обработчиков событий через атрибуты тегов к прямому связыванию функций с соответствующими атрибутами всё тез же элементов DOM. Это сделает код более надёжным и быстрым, но и количество кода вырастет кратно!</p>
<p>Вот только и с точки зрения JS работать с DOM напрямую утомительно. Поэтому большинство разработчиков использует библиотеки, скрывающие всю низкоуровневую работу с документом. Точно так же поступают и в мире ClojureScript, зачастую используя те же библиотеки из мира JS, только в более удобной для программирования именно на ClojureScript обёртке.</p>
<p>Таким образом, текущая версия приложения выглядит сложнее, чем могла бы быть. Но зато и никакой &quot;магии&quot; сейчас в проекте нет — видно, как ClojureScript работает с платформой. И в будущем вы сможете себе представить, как та или иная библиотека работает &quot;под капотом&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="Сложное-состояние"><a class="header" href="#Сложное-состояние">Сложное состояние</a></h1>
<p>Счётчик с одним значением — на самое впечатляющее приложение. В реальности состояние приложения включат в себя много &quot;движущихся частей&quot; и воздействуют на это состояние разные элементы интерфейса по разному. Усложним задачу: пусть теперь приложение показывает несколько счётчиков одновременно и позволяет добавлять новые счётчики равно как и удалять существующие.</p>
<p>Поменяются функция <code>draw</code> и содержимое атома <code>counter</code>. Кажется, стоит уже и назвать их иначе:</p>
<pre><code class="language-clojure">;; бывший counter
(defonce counters (atom {0 0}))

;; бывшая draw
(rum/defc view-counters &lt; rum/reactive []
  ;; состояние читается один раз в самом начале
  (let [cs (rum/react counters)]
    [:div
     [:ul
      ;; в качестве &quot;ребёнка&quot; тега может выступать список,
      ;; который может быть построен динамически
      (for [i (sort (keys cs))]
        [:li {:key (str &quot;counter-&quot; i)}
         (str (get cs i))
         [:button {:on-click (fn [] (swap! counters update i inc))} &quot;+&quot;]
         [:button {:on-click (fn [] (swap! counters update i dec))} &quot;-&quot;]
         [:button {:on-click (fn [] (swap! counters dissoc i))} &quot;X&quot;]])]
     [:button
      {:on-click
       (fn [] (swap! counters assoc
                    (inc (apply max (keys cs))) 0))}
      &quot;+&quot;]]))
</code></pre>
<p>Поменялось многое. В первую очередь атом теперь ссылается на отображение идентификатора счётчика в его значение. <code>{0 0}</code> означает &quot;счётчик с идентификатором 0 имеет значение 0&quot;.</p>
<p>Маркированный список <code>:ul</code> теперь наполняется динамически: функция <code>for</code> пробегается по отсортированному списку ключей упомянутого выше отображения и создаёт по элементу списка (<code>:li</code>) для каждого ключа. Обратите внимание: каждый элемент списка имеет <strong>атрибут</strong> <code>key</code> с уникальным значением. С помощью значений этого атрибута React понимает то, какие элементы в списке нужно обновить, какие нужно добавить, а какие убрать из документа — это достаточно важная оптимизация и если вы её не сделаете, React сообщит в консоли браузера об этом.</p>
<p>Стоит рассмотреть каждый обработчик нажатия, коих теперь уже четыре:</p>
<ul>
<li><code>(swap! counters update i inc)</code> можно трактовать как <code>(update @counters i inc)</code>, то есть увеличивает (<code>inc</code>) значение по ключу <code>i</code></li>
<li><code>(swap! counters update i inc)</code> — это <code>(update @counters i dec)</code>, то есть уменьшение (<code>dec</code>) значения по ключу <code>i</code></li>
<li><code>(swap! counters dissoc i)</code> — это <code>(dissoc @counters i)</code>, то есть удаление из отображения значения по ключу <code>i</code></li>
<li><code>(swap! counters assoc (inc (apply max (keys cs))) 0)</code> — это добавление значения <code>0</code> по ключу <code>(inc (apply max (keys cs)))</code>. Вычисляемый этим с виду сложным выражением ключ будет равен числу, следующему за максимальным значением среди ключей отображения <code>cs</code> (полученное выше значение по ссылке из атома <code>counters</code>).</li>
</ul>
<blockquote>
<p>Функция <code>max</code> находит максимальное значение среди своих аргументов. Но мы хотим применить её к <em>списку</em> значений. Здесь нам помогает <code>apply</code>, которая и распаковывает список аргументов: <code>(apply max '(4 2 3 5))</code> превращается в <code>(max 4 2 3 5)</code>.</p>
</blockquote>
<p>Сейчас каждая кнопка конструируется вручную и это выглядит как несколько довольно сильно похожих друг на друга кусочков кода. Но каждая кнопка, это всего лишь вектор, а значит мы можем обобщить создание кнопок. Причём мы можем сделать как отдельный компонент, так и просто формировать с помощью функции вектор. Сделаем сначала функцию:</p>
<pre><code class="language-clojure">(defn button [label function &amp; args]
  [:button
   {:on-click (fn [] (apply swap! counters function args))}
   label])

(rum/defc view-counters &lt; rum/reactive []
  (let [cs (rum/react counters)]
    [:div
     [:ul
      (for [i (sort (keys cs))]
        [:li {:key (str &quot;counter-&quot; i)}
         (str (get cs i))
         (button &quot;+&quot; update i inc)
         (button &quot;-&quot; update i dec)
         (button &quot;X&quot; dissoc i)])]
     (button &quot;+&quot; assoc (inc (apply max (keys cs))) 0)]))
</code></pre>
<p>&quot;<code>&amp; args</code>&quot; в списке параметров функции <code>button</code> означает, что при вызове этой функции все дополнительные аргументы после <code>label</code> и <code>function</code> будут доступны в теле функции в виде списка, связанного с одним параметром <code>args</code>. А далее в теле функции <code>button</code> всё та же функция <code>apply</code> применяет <code>swap!</code> к <code>counters</code>, <code>function</code> и любым другим дополнительным аргументам, которые были указаны при вызове <code>button</code>.</p>
<p>Даже такая простая функция как <code>button</code> в значительной степени разгружает код функции <code>view-counters</code>. А возможна такая лёгкая декомпозиция потому, что мы всего лишь манипулируем знакомыми структурами данных — вот она, сила data­driven design!</p>
<p>Что же случится, если заменить <code>defn</code> на <code>rum/defc</code> в объявлении <code>button</code>? Обычная функция станет компонентом! Полезно такое преобразование тем, что компонент может понять, что &quot;перерисовывать&quot; ничего не нужно, если с прошлого раза значения аргументов не изменились. Если компонент состоит из достаточно большого количества тегов, то выигрыш может быть существенным. Однако и просто так превращать каждую отдельно взятую функцию в компонент не стоит: компоненты &quot;тяжелее&quot; функций с точки зрения используемой памяти. Так что проще начинать с функций, а потом, если понадобится, превратить некоторые из них в компоненты — посмотрев с помощью <strong>профилировщика React</strong> что и когда перерисовывается и насколько затратна каждая конкретная перерисовка. Как говорится: &quot;семь раз отмерь, один раз отрежь!&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rum"><a class="header" href="#rum">Rum</a></h1>
<p>В мире JavaScript популярным средством построения графических интерфейсов является библиотека React. И так уж вышло, что библиотека эта резонирует с идеями функционального программирования: чистые функции без побочных эффектов вроде прямого изменения структуры документа, передача текущего состояния через аргументы функций вместо использования локальных изменяемых состояний.</p>
<blockquote>
<p>Да, современный React не запрещает использование компонент с собственными кусочками состояния, да и от чистых функций часто уходят в сторону классов. Но именно в мире ФП принято React использовать по старинке, в виде <em>функций из состояния в представление</em>.</p>
</blockquote>
<p>React можно использовать в ClJS и напрямую через JavaScript interoperability, но гораздо удобнее взять готовую обёртку. Rum — одна из таких обёрток. И это довольно тонкая обёртка в сравнении с другими библиотеками и фреймворками: вы имеете полную свободу во всём, кроме &quot;отрисовки&quot; интерфейса — Rum берёт на себя только эту часть работы.</p>
<h2 id="Установка-rum"><a class="header" href="#Установка-rum">Установка Rum</a></h2>
<p>Чтобы добавить Rum в проект, вам нужно в <code>shadow-cljs.edn</code> упомянуть библиотеку вместе с версией:</p>
<pre><code class="language-clojure"> …
 :dependencies
 [[rum &quot;0.12.10&quot;]]
 …
</code></pre>
<p>Теперь останется только перезапустить сервер Shadow ClJS. Но перед новым запуском сервера стоит установить ещё и соответствующие библиотеки для JavaScript. Это делается привычно силами NPM:</p>
<pre><code class="language-shell">$ npm install react@16 react-dom@16
</code></pre>
<blockquote>
<p>Версия 16 была выбрана потому, что Rum не использует новые штуки, появившиеся в React в последнее время. Но использует кое-какие старые, поэтому чтобы не видеть лишних предупреждений в консоли браузера, стоит остановиться на &quot;стабильной&quot; версии <code>react@16</code>. Впрочем, вы можете попробовать установить и самую свежую в качестве эксперимента.</p>
</blockquote>
<p>Теперь, когда зависимости установлены, запустите сервер Shadow ClJS.</p>
<h2 id="Первое-использование"><a class="header" href="#Первое-использование">Первое использование</a></h2>
<p>Перепишем счётчик с помощью Rum. Для этого импортируем модуль <code>rum.core</code> (изменения коснутся файла <code>app.cljs</code>):</p>
<pre><code class="language-clojure">(ns com.frontend.app
  (:require [rum.core :as rum]))

;; ^ здесь :as означает &quot;импортировать под именем таким-то&quot;
</code></pre>
<p>Теперь нужно удалить объявления функций <code>inc-counter</code> и <code>dec-counter</code> — сможем обойтись без них. А функцию <code>draw</code> нужно изменить таким образом:</p>
<pre><code class="language-clojure">(rum/defc draw &lt; rum/reactive []
  [:h1
   (str (rum/react counter))
   [:button {:on-click (fn [] (swap! counter inc))} &quot;+&quot;]
   [:button {:on-click (fn [] (swap! counter dec))} &quot;-&quot;]])
</code></pre>
<p>Здесь <code>defc</code> выступает как аналог <code>defn</code>, но объявляет не обычную функцию, а &quot;компонент&quot;. Последовательность &quot;<code>&lt; rum/reactive</code>&quot; называется добавлением &quot;примеси&quot; (&quot;mixin&quot;). Примеси добавляют функции­компоненту особые свойства.</p>
<p>Примесь <code>rum/reactive</code> делает компонент реактивным — реагирующим на изменения некоторых ссылок. В данном случае интерфейс будет реагировать на изменение атома <code>counter</code>, потому что в &quot;теле&quot; компонента этот атом использован в вызове <code>(rum/react counter)</code>. Такой вызов работает как разыменовывание ссылки и одновременно с этим подсказывает компоненту, за какими ссылками следует следить. При этом вам не нужно самостоятельно оформлять никакие подписки — если, конечно, вы не наблюдаете за атомами в коде, не связанном с построением GUI.</p>
<p>Компонент определён, теперь его нужно &quot;смонтировать&quot; — привязать к уже имеющемуся узлу дереве документа. Делается это так:</p>
<pre><code class="language-clojure">(defn init []
  (rum/mount (draw) (.querySelector js/document &quot;#root&quot;)))
</code></pre>
<p>Теперь счётчик должен снова заработать. А ведь кода стало меньше раза в три!</p>
<h2 id="rum-и-html"><a class="header" href="#rum-и-html">Rum и HTML</a></h2>
<p>Стоит отметить две вещи, которые уде видны в нашем коде:</p>
<ol>
<li>&quot;вёрстка&quot; выполнена с помощью обычных элементов, которыми мы описываем данные — векторов, отображений, ключевых слов, строк</li>
<li>Обработчики событий — это обычные функции на ClojureScript и больше нет нужды помнить особенности компиляции ClJS в JS</li>
</ol>
<p>Второй пункт скорее просто приятен. А вот первый демонстрирует одну из особенностей ClojureScript — построение доменно­ориентированных языков с помощью структур данных или, как ещё говорят, &quot;data­driven design&quot;. Строить языки под задачу вообще любят пользователи большинства лиспоподобных языков, но именно в Clojure предпочитают явно отделять что-то, описанное с помощью векторов и отображений, от &quot;обычного кода&quot;, записанного с помощью списков. Считается, что это разделение идёт на пользу читаемости.</p>
<p>Итак, HTML в Rum представлен как дерево из вложенных друг в друга векторов. Первый элемент вектора описывает имя тега, CSS­классы, ему назначенные и идентификатор в любых разумных сочетаниях:</p>
<ul>
<li><code>:div#content</code> — это <code>&lt;div id=&quot;content&quot;&gt;</code></li>
<li><code>:.counter</code> — это <code>&lt;div class=&quot;counter&quot;&gt;</code>, потому что тег <code>div</code> подразумевается</li>
<li><code>:span#foo.bar.baz</code> — это <code>&lt;span id=&quot;foo&quot; class=&quot;bar baz&quot;&gt;</code></li>
</ul>
<p>Если нужно добавить какие-то дополнительные атрибуты тегу, то вторым элементов вектора указывается отображение, где имена атрибутов кодируются ключевыми словами, а значения строками (или тем, что безопасно приводится к строке). К примеру, обработчики нажатия у тегов <code>button</code> в нашем коде записаны как <code>{:on-click (fn [] …)}</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
